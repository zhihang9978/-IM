# Ëìù‰ø°IM‰øÆÂ§çË∑ØÁ∫øÂõæ
## Âü∫‰∫éÂÆ°Êü•Êä•ÂëäÁöÑÂèØÊâßË°åËÆ°Âàí

**Âà∂ÂÆöÊó∂Èó¥**: 2025-10-18  
**È¢ÑËÆ°ÊÄªÂ∑•Êúü**: 2-4Âë®  
**Âü∫‰∫éÊñáÊ°£**: `PROJECT_REVIEW_REPORT.md`

---

# üéØ ‰øÆÂ§ç‰ºòÂÖàÁ∫ßÊÄªËßà

```
‰ºòÂÖàÁ∫ßÂàíÂàÜ:
P0 (‰∏•Èáç) ‚Üí ÂøÖÈ°ªÁ´ãÂç≥‰øÆÂ§ç,ÂΩ±ÂìçÊ†∏ÂøÉÂäüËÉΩ
P1 (ÈáçË¶Å) ‚Üí Â∫îËØ•Â∞ΩÂø´‰øÆÂ§ç,ÂΩ±ÂìçÁî®Êà∑‰ΩìÈ™å
P2 (‰∏ÄËà¨) ‚Üí Âª∫ËÆÆ‰øÆÂ§ç,‰ºòÂåñÊÄßËÉΩÂíåÂÆâÂÖ®
```

| ‰ºòÂÖàÁ∫ß | ÈóÆÈ¢ò | Â∑•Êúü | Á¥ßÊÄ•Â∫¶ |
|--------|------|------|--------|
| **P0** | Áæ§ËÅäÂäüËÉΩÁº∫Â§± | 3-4Â§© | üî¥üî¥üî¥üî¥üî¥ |
| **P0** | WebSocketÁÆ°ÁêÜ‰∏çÂÆåÂñÑ | 2Â§© | üî¥üî¥üî¥üî¥‚òÜ |
| **P0** | Ê∂àÊÅØÂèØÈù†ÊÄß‰∏çË∂≥ | 2-3Â§© | üî¥üî¥üî¥üî¥‚òÜ |
| **P1** | Áº∫Â∞ëProtobuf | 2Â§© | üü°üü°üü°‚òÜ‚òÜ |
| **P1** | Ê∂àÊÅØÂêåÊ≠•Êú∫Âà∂ | 1Â§© | üü°üü°üü°‚òÜ‚òÜ |
| **P2** | CloudflareÈÖçÁΩÆÈ™åËØÅ | 0.5Â§© | üü¢üü¢‚òÜ‚òÜ‚òÜ |

---

# üìã Á¨¨‰∏ÄÂë®: P0‰∏•ÈáçÁº∫Èô∑‰øÆÂ§ç

## ‰ªªÂä°1: ÂÆûÁé∞Áæ§ËÅäÂäüËÉΩ (3-4Â§©) üî¥

### ‰ªªÂä°ÂàÜËß£

**Day 1-2: ÂêéÁ´ØÂÆûÁé∞**
```
[ ] 1.1 ÂàõÂª∫Áæ§ÁªÑService (2-3Â∞èÊó∂)
[ ] 1.2 ÂàõÂª∫Áæ§ÁªÑDAO (1-2Â∞èÊó∂)
[ ] 1.3 ÂàõÂª∫Áæ§ÁªÑAPI Handler (2-3Â∞èÊó∂)
[ ] 1.4 ‰øÆÊîπÊ∂àÊÅØServiceÊîØÊåÅÁæ§Ê∂àÊÅØ (2-3Â∞èÊó∂)
[ ] 1.5 ÊµãËØïÁæ§ÁªÑAPI (1Â∞èÊó∂)
```

**Day 3: AndroidÂÆ¢Êà∑Á´Ø**
```
[ ] 1.6 ÂØπÊé•Áæ§ÁªÑAPI (2-3Â∞èÊó∂)
[ ] 1.7 ÂÆåÂñÑGroupChatActivity (3-4Â∞èÊó∂)
[ ] 1.8 ÂÆûÁé∞Áæ§ÊàêÂëòÁÆ°ÁêÜ (2Â∞èÊó∂)
```

**Day 4: ËÅîË∞ÉÊµãËØï**
```
[ ] 1.9 Á´ØÂà∞Á´ØÊµãËØï (2Â∞èÊó∂)
[ ] 1.10 ‰øÆÂ§çBug (2-4Â∞èÊó∂)
```

### ËØ¶ÁªÜÂÆûÊñΩÊ≠•È™§

#### Step 1: ÂàõÂª∫ `group_service.go`

```go
// apps/backend/internal/service/group_service.go
package service

import (
	"errors"
	"github.com/lanxin/im-backend/internal/dao"
	"github.com/lanxin/im-backend/internal/model"
	"github.com/lanxin/im-backend/internal/websocket"
)

type GroupService struct {
	groupDAO       *dao.GroupDAO
	groupMemberDAO *dao.GroupMemberDAO
	userDAO        *dao.UserDAO
	logDAO         *dao.OperationLogDAO
	hub            *websocket.Hub
}

func NewGroupService(hub *websocket.Hub) *GroupService {
	return &GroupService{
		groupDAO:       dao.NewGroupDAO(),
		groupMemberDAO: dao.NewGroupMemberDAO(),
		userDAO:        dao.NewUserDAO(),
		logDAO:         dao.NewOperationLogDAO(),
		hub:            hub,
	}
}

// CreateGroup ÂàõÂª∫Áæ§ÁªÑ
func (s *GroupService) CreateGroup(ownerID uint, name, avatar string, memberIDs []uint, ip, userAgent string) (*model.Group, error) {
	// È™åËØÅÊàêÂëòÊòØÂê¶Â≠òÂú®
	for _, memberID := range memberIDs {
		if _, err := s.userDAO.GetByID(memberID); err != nil {
			return nil, errors.New("member not found")
		}
	}
	
	// ÂàõÂª∫Áæ§ÁªÑ
	group := &model.Group{
		Name:        name,
		Avatar:      avatar,
		OwnerID:     ownerID,
		Type:        model.GroupTypeNormal,
		MemberCount: len(memberIDs) + 1, // +1 ÂåÖÂê´ÂàõÂª∫ËÄÖ
	}
	
	if err := s.groupDAO.Create(group); err != nil {
		return nil, err
	}
	
	// Ê∑ªÂä†Áæ§‰∏ª‰∏∫ÊàêÂëò
	if err := s.addMember(group.ID, ownerID, model.GroupRoleOwner); err != nil {
		return nil, err
	}
	
	// Ê∑ªÂä†ÂÖ∂‰ªñÊàêÂëò
	for _, memberID := range memberIDs {
		if err := s.addMember(group.ID, memberID, model.GroupRoleMember); err != nil {
			// ËÆ∞ÂΩïÈîôËØØ‰ΩÜÁªßÁª≠
			continue
		}
	}
	
	// ËÆ∞ÂΩïÊìç‰ΩúÊó•Âøó
	s.logDAO.CreateLog(dao.LogRequest{
		Action:    model.ActionGroupCreate,
		UserID:    &ownerID,
		IP:        ip,
		UserAgent: userAgent,
		Details: map[string]interface{}{
			"group_id":     group.ID,
			"group_name":   name,
			"member_count": len(memberIDs) + 1,
		},
		Result: model.ResultSuccess,
	})
	
	// ÈÄöÁü•ÊâÄÊúâÊàêÂëò
	for _, memberID := range append(memberIDs, ownerID) {
		if s.hub.IsUserOnline(memberID) {
			s.hub.SendToUser(memberID, map[string]interface{}{
				"type": "group_created",
				"data": group,
			})
		}
	}
	
	return group, nil
}

// AddMembers Ê∑ªÂä†Áæ§ÊàêÂëò
func (s *GroupService) AddMembers(groupID, operatorID uint, memberIDs []uint, ip, userAgent string) error {
	// È™åËØÅÊìç‰ΩúËÄÖÊùÉÈôê
	role, err := s.groupMemberDAO.GetMemberRole(groupID, operatorID)
	if err != nil || (role != model.GroupRoleOwner && role != model.GroupRoleAdmin) {
		return errors.New("no permission")
	}
	
	// Ëé∑ÂèñÁæ§ÁªÑ‰ø°ÊÅØ
	group, err := s.groupDAO.GetByID(groupID)
	if err != nil {
		return err
	}
	
	// Ê∑ªÂä†ÊàêÂëò
	for _, memberID := range memberIDs {
		if err := s.addMember(groupID, memberID, model.GroupRoleMember); err != nil {
			continue
		}
	}
	
	// Êõ¥Êñ∞Áæ§ÊàêÂëòÊï∞Èáè
	group.MemberCount += len(memberIDs)
	s.groupDAO.Update(group)
	
	// ËÆ∞ÂΩïÊó•Âøó
	s.logDAO.CreateLog(dao.LogRequest{
		Action:    model.ActionGroupAddMember,
		UserID:    &operatorID,
		IP:        ip,
		UserAgent: userAgent,
		Details: map[string]interface{}{
			"group_id":   groupID,
			"member_ids": memberIDs,
		},
		Result: model.ResultSuccess,
	})
	
	return nil
}

// SendGroupMessage ÂèëÈÄÅÁæ§Ê∂àÊÅØ
func (s *GroupService) SendGroupMessage(groupID, senderID uint, content, msgType string, fileURL *string) (*model.Message, error) {
	// È™åËØÅÂèëÈÄÅËÄÖÊòØÂê¶ÊòØÁæ§ÊàêÂëò
	if !s.groupMemberDAO.IsMember(groupID, senderID) {
		return nil, errors.New("not a group member")
	}
	
	// ÂàõÂª∫Ê∂àÊÅØ
	message := &model.Message{
		SenderID:   senderID,
		GroupID:    &groupID,
		Content:    content,
		Type:       msgType,
		Status:     model.MessageStatusSent,
	}
	
	if fileURL != nil {
		message.FileURL = *fileURL
	}
	
	// ‰øùÂ≠òÊ∂àÊÅØ
	if err := s.messageDAO.Create(message); err != nil {
		return nil, err
	}
	
	// Ëé∑ÂèñÊâÄÊúâÁæ§ÊàêÂëò
	members, err := s.groupMemberDAO.GetMembers(groupID)
	if err != nil {
		return message, nil
	}
	
	// Êé®ÈÄÅÁªôÂú®Á∫øÊàêÂëò
	for _, member := range members {
		if member.UserID != senderID && s.hub.IsUserOnline(member.UserID) {
			s.hub.SendMessageNotification(member.UserID, message)
		}
	}
	
	return message, nil
}

// ÂÜÖÈÉ®ÊñπÊ≥ï: Ê∑ªÂä†Âçï‰∏™ÊàêÂëò
func (s *GroupService) addMember(groupID, userID uint, role string) error {
	member := &model.GroupMember{
		GroupID: groupID,
		UserID:  userID,
		Role:    role,
	}
	return s.groupMemberDAO.Create(member)
}
```

#### Step 2: ÂàõÂª∫ `group_dao.go`

```go
// apps/backend/internal/dao/group_dao.go
package dao

import (
	"github.com/lanxin/im-backend/internal/model"
	"github.com/lanxin/im-backend/internal/pkg/mysql"
)

type GroupDAO struct{}

func NewGroupDAO() *GroupDAO {
	return &GroupDAO{}
}

func (d *GroupDAO) Create(group *model.Group) error {
	return mysql.DB.Create(group).Error
}

func (d *GroupDAO) GetByID(id uint) (*model.Group, error) {
	var group model.Group
	err := mysql.DB.Preload("Owner").Preload("Members").First(&group, id).Error
	return &group, err
}

func (d *GroupDAO) Update(group *model.Group) error {
	return mysql.DB.Save(group).Error
}

func (d *GroupDAO) Delete(id uint) error {
	return mysql.DB.Delete(&model.Group{}, id).Error
}

func (d *GroupDAO) GetUserGroups(userID uint) ([]model.Group, error) {
	var groups []model.Group
	err := mysql.DB.
		Joins("JOIN group_members ON groups.id = group_members.group_id").
		Where("group_members.user_id = ?", userID).
		Find(&groups).Error
	return groups, err
}

// GroupMemberDAO
type GroupMemberDAO struct{}

func NewGroupMemberDAO() *GroupMemberDAO {
	return &GroupMemberDAO{}
}

func (d *GroupMemberDAO) Create(member *model.GroupMember) error {
	return mysql.DB.Create(member).Error
}

func (d *GroupMemberDAO) GetMembers(groupID uint) ([]model.GroupMember, error) {
	var members []model.GroupMember
	err := mysql.DB.Preload("User").Where("group_id = ?", groupID).Find(&members).Error
	return members, err
}

func (d *GroupMemberDAO) IsMember(groupID, userID uint) bool {
	var count int64
	mysql.DB.Model(&model.GroupMember{}).
		Where("group_id = ? AND user_id = ?", groupID, userID).
		Count(&count)
	return count > 0
}

func (d *GroupMemberDAO) GetMemberRole(groupID, userID uint) (string, error) {
	var member model.GroupMember
	err := mysql.DB.Where("group_id = ? AND user_id = ?", groupID, userID).First(&member).Error
	return member.Role, err
}

func (d *GroupMemberDAO) RemoveMember(groupID, userID uint) error {
	return mysql.DB.
		Where("group_id = ? AND user_id = ?", groupID, userID).
		Delete(&model.GroupMember{}).Error
}
```

#### Step 3: ÂàõÂª∫API Handler

```go
// apps/backend/internal/api/group.go
package api

import (
	"net/http"
	"strconv"
	
	"github.com/gin-gonic/gin"
	"github.com/lanxin/im-backend/internal/middleware"
	"github.com/lanxin/im-backend/internal/service"
	"github.com/lanxin/im-backend/internal/websocket"
)

type GroupHandler struct {
	groupService *service.GroupService
}

func NewGroupHandler(hub *websocket.Hub) *GroupHandler {
	return &GroupHandler{
		groupService: service.NewGroupService(hub),
	}
}

// CreateGroup ÂàõÂª∫Áæ§ÁªÑ
// POST /api/v1/groups
func (h *GroupHandler) CreateGroup(c *gin.Context) {
	userID, _ := middleware.GetUserID(c)
	
	var req struct {
		Name      string   `json:"name" binding:"required"`
		Avatar    string   `json:"avatar"`
		MemberIDs []uint   `json:"member_ids" binding:"required"`
	}
	
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "Invalid request",
			"data":    nil,
		})
		return
	}
	
	ip := c.ClientIP()
	userAgent := c.GetHeader("User-Agent")
	
	group, err := h.groupService.CreateGroup(
		userID,
		req.Name,
		req.Avatar,
		req.MemberIDs,
		ip,
		userAgent,
	)
	
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": err.Error(),
			"data":    nil,
		})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"group": group,
		},
	})
}

// GetGroupInfo Ëé∑ÂèñÁæ§ÁªÑ‰ø°ÊÅØ
// GET /api/v1/groups/:id
func (h *GroupHandler) GetGroupInfo(c *gin.Context) {
	groupID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
	
	group, err := h.groupService.GetGroupInfo(uint(groupID))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"code":    404,
			"message": "Group not found",
			"data":    nil,
		})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"group": group,
		},
	})
}

// GetGroupMembers Ëé∑ÂèñÁæ§ÊàêÂëòÂàóË°®
// GET /api/v1/groups/:id/members
func (h *GroupHandler) GetGroupMembers(c *gin.Context) {
	groupID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
	
	members, err := h.groupService.GetMembers(uint(groupID))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": err.Error(),
			"data":    nil,
		})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"members": members,
		},
	})
}

// AddMembers Ê∑ªÂä†Áæ§ÊàêÂëò
// POST /api/v1/groups/:id/members
func (h *GroupHandler) AddMembers(c *gin.Context) {
	userID, _ := middleware.GetUserID(c)
	groupID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
	
	var req struct {
		MemberIDs []uint `json:"member_ids" binding:"required"`
	}
	
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "Invalid request",
			"data":    nil,
		})
		return
	}
	
	ip := c.ClientIP()
	userAgent := c.GetHeader("User-Agent")
	
	err := h.groupService.AddMembers(uint(groupID), userID, req.MemberIDs, ip, userAgent)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": err.Error(),
			"data":    nil,
		})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    nil,
	})
}

// SendGroupMessage ÂèëÈÄÅÁæ§Ê∂àÊÅØ
// POST /api/v1/groups/:id/messages
func (h *GroupHandler) SendGroupMessage(c *gin.Context) {
	userID, _ := middleware.GetUserID(c)
	groupID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
	
	var req struct {
		Content string  `json:"content" binding:"required"`
		Type    string  `json:"type"`
		FileURL *string `json:"file_url"`
	}
	
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "Invalid request",
			"data":    nil,
		})
		return
	}
	
	if req.Type == "" {
		req.Type = "text"
	}
	
	message, err := h.groupService.SendGroupMessage(
		uint(groupID),
		userID,
		req.Content,
		req.Type,
		req.FileURL,
	)
	
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": err.Error(),
			"data":    nil,
		})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"message": message,
		},
	})
}
```

#### Step 4: Ê≥®ÂÜåË∑ØÁî±

```go
// apps/backend/cmd/server/main.go
// Âú®authorizedÁªÑ‰∏≠Ê∑ªÂä†Áæ§ÁªÑË∑ØÁî±

groupHandler := api.NewGroupHandler(hub)

// Áæ§ÁªÑÁõ∏ÂÖ≥
authorized.POST("/groups", groupHandler.CreateGroup)
authorized.GET("/groups/:id", groupHandler.GetGroupInfo)
authorized.GET("/groups/:id/members", groupHandler.GetGroupMembers)
authorized.POST("/groups/:id/members", groupHandler.AddMembers)
authorized.DELETE("/groups/:id/members/:user_id", groupHandler.RemoveMember)
authorized.POST("/groups/:id/messages", groupHandler.SendGroupMessage)
authorized.PUT("/groups/:id", groupHandler.UpdateGroup)
authorized.DELETE("/groups/:id", groupHandler.DisbandGroup)
```

#### Step 5: AndroidÂÆ¢Êà∑Á´ØÂØπÊé•

```kotlin
// apps/android/.../data/remote/ApiService.kt

// Áæ§ÁªÑAPI
@POST("groups")
suspend fun createGroup(@Body request: CreateGroupRequest): ApiResponse<GroupResponse>

@GET("groups/{id}")
suspend fun getGroupInfo(@Path("id") groupId: Long): ApiResponse<GroupResponse>

@GET("groups/{id}/members")
suspend fun getGroupMembers(@Path("id") groupId: Long): ApiResponse<GroupMembersResponse>

@POST("groups/{id}/members")
suspend fun addGroupMembers(
    @Path("id") groupId: Long,
    @Body memberIds: Map<String, List<Long>>
): ApiResponse<Any?>

@POST("groups/{id}/messages")
suspend fun sendGroupMessage(
    @Path("id") groupId: Long,
    @Body request: SendMessageRequest
): ApiResponse<MessageResponse>

// ËØ∑Ê±ÇÊï∞ÊçÆÁ±ª
data class CreateGroupRequest(
    val name: String,
    val avatar: String?,
    val member_ids: List<Long>
)

// ÂìçÂ∫îÊï∞ÊçÆÁ±ª
data class GroupResponse(
    val id: Long,
    val name: String,
    val avatar: String?,
    val owner_id: Long,
    val member_count: Int,
    val created_at: Long
)

data class GroupMembersResponse(
    val members: List<GroupMember>
)

data class GroupMember(
    val user_id: Long,
    val role: String,
    val nickname: String?,
    val joined_at: Long
)
```

### ÊµãËØïÊ∏ÖÂçï

```bash
# ÂêéÁ´ØÊµãËØï
[ ] ÂàõÂª∫Áæ§ÁªÑ POST /api/v1/groups
[ ] Ëé∑ÂèñÁæ§‰ø°ÊÅØ GET /api/v1/groups/:id
[ ] Ëé∑ÂèñÁæ§ÊàêÂëò GET /api/v1/groups/:id/members
[ ] Ê∑ªÂä†ÊàêÂëò POST /api/v1/groups/:id/members
[ ] ÂèëÈÄÅÁæ§Ê∂àÊÅØ POST /api/v1/groups/:id/messages

# AndroidÊµãËØï
[ ] ÂàõÂª∫Áæ§ÁªÑÁïåÈù¢
[ ] Áæ§ËÅäÁïåÈù¢ÊòæÁ§∫
[ ] ÂèëÈÄÅÁæ§Ê∂àÊÅØ
[ ] Êé•Êî∂Áæ§Ê∂àÊÅØ
[ ] Ê∑ªÂä†Áæ§ÊàêÂëò
```

---

## ‰ªªÂä°2: ÂÆåÂñÑWebSocketÁÆ°ÁêÜ (2Â§©) üî¥

### ÂÆûÊñΩÊ≠•È™§

#### Step 1: Ê∑ªÂä†ËøûÊé•Ê±†ÈôêÂà∂

```go
// apps/backend/internal/websocket/hub.go

type Hub struct {
	clients     map[*Client]bool
	userClients map[uint][]*Client
	broadcast   chan []byte
	register    chan *Client
	unregister  chan *Client
	mu sync.RWMutex
	
	// ‚úÖ Êñ∞Â¢ûÈÖçÁΩÆ
	maxClients        int           // ÊúÄÂ§ßÊÄªËøûÊé•Êï∞
	maxClientsPerUser int           // ÂçïÁî®Êà∑ÊúÄÂ§ßËÆæÂ§áÊï∞
	clientTimeout     time.Duration // ËøûÊé•Ë∂ÖÊó∂Êó∂Èó¥
	cleanupTicker     *time.Ticker  // Ê∏ÖÁêÜÂÆöÊó∂Âô®
	lastActivity      map[*Client]time.Time // ÊúÄÂêéÊ¥ªÂä®Êó∂Èó¥
}

func NewHub(maxClients, maxClientsPerUser int, timeout time.Duration) *Hub {
	h := &Hub{
		clients:           make(map[*Client]bool),
		userClients:       make(map[uint][]*Client),
		broadcast:         make(chan []byte, 10000), // Êâ©Â§ßbuffer
		register:          make(chan *Client),
		unregister:        make(chan *Client),
		maxClients:        maxClients,
		maxClientsPerUser: maxClientsPerUser,
		clientTimeout:     timeout,
		lastActivity:      make(map[*Client]time.Time),
	}
	
	// ÂêØÂä®Ê∏ÖÁêÜÂçèÁ®ã
	h.startCleanupRoutine()
	
	return h
}

// Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•Êé•ÂèóÊñ∞ËøûÊé•
func (h *Hub) canAcceptConnection(userID uint) bool {
	h.mu.RLock()
	defer h.mu.RUnlock()
	
	// Ê£ÄÊü•ÊÄªËøûÊé•Êï∞
	if len(h.clients) >= h.maxClients {
		log.Printf("Max clients reached: %d", len(h.clients))
		return false
	}
	
	// Ê£ÄÊü•ÂçïÁî®Êà∑ËÆæÂ§áÊï∞
	if len(h.userClients[userID]) >= h.maxClientsPerUser {
		log.Printf("Max clients per user reached for user %d", userID)
		return false
	}
	
	return true
}

// ÂÆöÊúüÊ∏ÖÁêÜÂÉµÂ∞∏ËøûÊé•
func (h *Hub) startCleanupRoutine() {
	h.cleanupTicker = time.NewTicker(30 * time.Second)
	go func() {
		for range h.cleanupTicker.C {
			h.cleanupStaleConnections()
		}
	}()
}

func (h *Hub) cleanupStaleConnections() {
	h.mu.Lock()
	defer h.mu.Unlock()
	
	now := time.Now()
	for client, _ := range h.clients {
		if lastActive, ok := h.lastActivity[client]; ok {
			if now.Sub(lastActive) > h.clientTimeout {
				// Ë∂ÖÊó∂,ÂÖ≥Èó≠ËøûÊé•
				log.Printf("Closing stale connection for user %d", client.userID)
				close(client.send)
				delete(h.clients, client)
				delete(h.lastActivity, client)
				h.removeClientFromUser(client)
			}
		}
	}
}

// Êõ¥Êñ∞Ê¥ªÂä®Êó∂Èó¥
func (h *Hub) updateActivity(client *Client) {
	h.mu.Lock()
	defer h.mu.Unlock()
	h.lastActivity[client] = time.Now()
}
```

#### Step 2: ‰øÆÊîπËøûÊé•Â§ÑÁêÜ

```go
// apps/backend/internal/websocket/client.go

func ServeWS(hub *Hub, c *gin.Context, secret string) {
	// È™åËØÅtoken
	tokenString := c.Query("token")
	if tokenString == "" {
		c.JSON(401, gin.H{"code": 401, "message": "Token required"})
		return
	}
	
	claims, err := jwt.ParseToken(tokenString, secret)
	if err != nil {
		c.JSON(401, gin.H{"code": 401, "message": "Invalid token"})
		return
	}
	
	// ‚úÖ Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•Êé•ÂèóÊñ∞ËøûÊé•
	if !hub.canAcceptConnection(claims.UserID) {
		c.JSON(503, gin.H{
			"code":    503,
			"message": "Server too busy or too many devices",
			"data":    nil,
		})
		return
	}
	
	// ÂçáÁ∫ßËøûÊé•
	conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
	if err != nil {
		log.Printf("Failed to upgrade connection: %v", err)
		return
	}
	
	client := &Client{
		hub:      hub,
		conn:     conn,
		send:     make(chan []byte, 256),
		userID:   claims.UserID,
		username: claims.Username,
	}
	
	client.hub.register <- client
	
	go client.writePump()
	go client.readPump()
}

// readPump‰∏≠Êõ¥Êñ∞Ê¥ªÂä®Êó∂Èó¥
func (c *Client) readPump() {
	defer func() {
		c.hub.unregister <- c
		c.conn.Close()
	}()
	
	c.conn.SetReadLimit(maxMessageSize)
	c.conn.SetReadDeadline(time.Now().Add(pongWait))
	c.conn.SetPongHandler(func(string) error {
		c.conn.SetReadDeadline(time.Now().Add(pongWait))
		c.hub.updateActivity(c) // ‚úÖ Êõ¥Êñ∞Ê¥ªÂä®Êó∂Èó¥
		return nil
	})
	
	for {
		_, message, err := c.conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.Printf("WebSocket error: %v", err)
			}
			break
		}
		
		c.hub.updateActivity(c) // ‚úÖ Êõ¥Êñ∞Ê¥ªÂä®Êó∂Èó¥
		c.handleMessage(message)
	}
}
```

#### Step 3: ÈÖçÁΩÆÊñá‰ª∂

```yaml
# config.yaml
websocket:
  max_connections: 10000      # ÊúÄÂ§ßÊÄªËøûÊé•Êï∞
  max_connections_per_user: 5 # ÂçïÁî®Êà∑ÊúÄÂ§ßËÆæÂ§áÊï∞
  connection_timeout: 300     # ËøûÊé•Ë∂ÖÊó∂(Áßí)
  read_buffer_size: 1024
  write_buffer_size: 1024
  broadcast_buffer: 10000     # broadcast channel buffer
  heartbeat_interval: 30
  max_message_size: 10240
```

### ÊµãËØï

```bash
# ÂéãÂäõÊµãËØï
[ ] Ê®°Êãü10000Âπ∂ÂèëËøûÊé•
[ ] Ê®°ÊãüÂçïÁî®Êà∑5‰∏™ËÆæÂ§á
[ ] ÊµãËØïÂÉµÂ∞∏ËøûÊé•Ê∏ÖÁêÜ
[ ] ÊµãËØïËøûÊé•ÈôêÂà∂
```

---

## ‰ªªÂä°3: Ê∂àÊÅØÂèØÈù†ÊÄß‰øùËØÅ (2-3Â§©) üî¥

### ÂÆûÊñΩÊ≠•È™§

#### Step 1: Ê∑ªÂä†Ê∂àÊÅØACKÊú∫Âà∂

```go
// 1. Ê∑ªÂä†ACK API
// apps/backend/internal/api/message.go

// AckDelivered Á°ÆËÆ§Ê∂àÊÅØÂ∑≤ÈÄÅËææ
// POST /api/v1/messages/:id/ack/delivered
func (h *MessageHandler) AckDelivered(c *gin.Context) {
	userID, _ := middleware.GetUserID(c)
	messageID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
	
	message, err := h.messageService.GetMessage(uint(messageID))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"code":    404,
			"message": "Message not found",
			"data":    nil,
		})
		return
	}
	
	// Âè™ÊúâÊé•Êî∂ËÄÖËÉΩÁ°ÆËÆ§
	if message.ReceiverID != userID {
		c.JSON(http.StatusForbidden, gin.H{
			"code":    403,
			"message": "Not authorized",
			"data":    nil,
		})
		return
	}
	
	// Êõ¥Êñ∞Ê∂àÊÅØÁä∂ÊÄÅ‰∏∫Â∑≤ÈÄÅËææ
	err = h.messageService.UpdateStatus(uint(messageID), model.MessageStatusDelivered)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": err.Error(),
			"data":    nil,
		})
		return
	}
	
	// ÈÄöÁü•ÂèëÈÄÅËÄÖ
	h.hub.SendMessageStatusUpdate(message.SenderID, uint(messageID), "delivered")
	
	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    nil,
	})
}

// AckRead Á°ÆËÆ§Ê∂àÊÅØÂ∑≤ËØª
// POST /api/v1/messages/:id/ack/read
func (h *MessageHandler) AckRead(c *gin.Context) {
	userID, _ := middleware.GetUserID(c)
	messageID, _ := strconv.ParseUint(c.Param("id"), 10, 32)
	
	message, err := h.messageService.GetMessage(uint(messageID))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"code":    404,
			"message": "Message not found",
			"data":    nil,
		})
		return
	}
	
	if message.ReceiverID != userID {
		c.JSON(http.StatusForbidden, gin.H{
			"code":    403,
			"message": "Not authorized",
			"data":    nil,
		})
		return
	}
	
	// Êõ¥Êñ∞Ê∂àÊÅØÁä∂ÊÄÅ‰∏∫Â∑≤ËØª
	err = h.messageService.UpdateStatus(uint(messageID), model.MessageStatusRead)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": err.Error(),
			"data":    nil,
		})
		return
	}
	
	// ÈÄöÁü•ÂèëÈÄÅËÄÖ
	h.hub.SendMessageStatusUpdate(message.SenderID, uint(messageID), "read")
	
	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    nil,
	})
}
```

#### Step 2: Á¶ªÁ∫øÊ∂àÊÅØÈòüÂàó

```go
// apps/backend/internal/service/message_service.go

func (s *MessageService) SendMessage(...) (*model.Message, error) {
	// ... ÂàõÂª∫Ê∂àÊÅØ ...
	
	// Ê£ÄÊü•Êé•Êî∂ËÄÖÊòØÂê¶Âú®Á∫ø
	if s.hub.IsUserOnline(receiverID) {
		// Âú®Á∫ø:Â∞ùËØïÊé®ÈÄÅ
		err := s.hub.SendMessageNotification(receiverID, message)
		if err != nil {
			// Êé®ÈÄÅÂ§±Ë¥•,Â≠òÂÖ•Á¶ªÁ∫øÈòüÂàó
			s.saveOfflineMessage(receiverID, message)
		}
	} else {
		// Á¶ªÁ∫ø:Â≠òÂÖ•Á¶ªÁ∫øÈòüÂàó
		s.saveOfflineMessage(receiverID, message)
	}
	
	return message, nil
}

// ‰øùÂ≠òÁ¶ªÁ∫øÊ∂àÊÅØ
func (s *MessageService) saveOfflineMessage(userID uint, message *model.Message) {
	key := fmt.Sprintf("offline_msg:%d", userID)
	
	// Â≠òÂÖ•Redis List
	s.redis.RPush(context.Background(), key, message.ID)
	
	// ËÆæÁΩÆ7Â§©ËøáÊúü
	s.redis.Expire(context.Background(), key, 7*24*time.Hour)
}

// Ëé∑ÂèñÁ¶ªÁ∫øÊ∂àÊÅØ
func (s *MessageService) GetOfflineMessages(userID uint) ([]model.Message, error) {
	key := fmt.Sprintf("offline_msg:%d", userID)
	
	// ‰ªéRedisËØªÂèñÊ∂àÊÅØIDÂàóË°®
	messageIDs, err := s.redis.LRange(context.Background(), key, 0, -1).Result()
	if err != nil {
		return nil, err
	}
	
	messages := []model.Message{}
	for _, idStr := range messageIDs {
		id, _ := strconv.ParseUint(idStr, 10, 32)
		msg, err := s.messageDAO.GetByID(uint(id))
		if err == nil {
			messages = append(messages, *msg)
		}
	}
	
	// Ê∏ÖÁ©∫ÈòüÂàó
	s.redis.Del(context.Background(), key)
	
	return messages, nil
}

// Áî®Êà∑‰∏äÁ∫øÊó∂ÊãâÂèñÁ¶ªÁ∫øÊ∂àÊÅØAPI
// GET /api/v1/messages/offline
func (h *MessageHandler) GetOfflineMessages(c *gin.Context) {
	userID, _ := middleware.GetUserID(c)
	
	messages, err := h.messageService.GetOfflineMessages(userID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": err.Error(),
			"data":    nil,
		})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"messages": messages,
			"count":    len(messages),
		},
	})
}
```

#### Step 3: AndroidÂÆ¢Êà∑Á´ØACK

```kotlin
// WebSocketClientÊî∂Âà∞Ê∂àÊÅØÂêéÁ´ãÂç≥ACK

override fun onMessage(text: String) {
    val message = gson.fromJson(text, WebSocketMessage::class.java)
    
    when (message.type) {
        "message" -> {
            val msg = message.data as Message
            
            // ‰øùÂ≠òÂà∞Êú¨Âú∞Êï∞ÊçÆÂ∫ì
            messageDao.insert(msg)
            
            // ‚úÖ Á´ãÂç≥ÂèëÈÄÅÈÄÅËææACK
            apiService.ackDelivered(msg.id)
            
            // ÊòæÁ§∫ÈÄöÁü•
            showNotification(msg)
            
            // Â¶ÇÊûúÂú®ËÅäÂ§©ÁïåÈù¢,Ê†áËÆ∞Â∑≤ËØª
            if (isInChat(msg.conversation_id)) {
                apiService.ackRead(msg.id)
            }
        }
    }
}

// Áî®Êà∑ÊâìÂºÄËÅäÂ§©ÁïåÈù¢Êó∂
fun onChatOpened(conversationId: Long) {
    // Ëé∑ÂèñËØ•‰ºöËØùÊâÄÊúâÊú™ËØªÊ∂àÊÅØ
    val unreadMessages = messageDao.getUnreadMessages(conversationId)
    
    // ÊâπÈáèÊ†áËÆ∞Â∑≤ËØª
    unreadMessages.forEach { msg ->
        apiService.ackRead(msg.id)
    }
}

// AppÂêØÂä®Êó∂ÊãâÂèñÁ¶ªÁ∫øÊ∂àÊÅØ
fun onAppLaunched() {
    lifecycleScope.launch {
        val offlineMessages = apiService.getOfflineMessages()
        offlineMessages.forEach { msg ->
            messageDao.insert(msg)
            apiService.ackDelivered(msg.id)
        }
    }
}
```

### ÊµãËØïÊ∏ÖÂçï

```bash
# ÊµãËØïÈÄÅËææACK
[ ] ÂèëÈÄÅÊ∂àÊÅØ‚ÜíÊé•Êî∂ËÄÖÂú®Á∫ø‚ÜíÁ´ãÂç≥ACK‚ÜíÂèëÈÄÅËÄÖÊî∂Âà∞"Â∑≤ÈÄÅËææ"

# ÊµãËØïÂ∑≤ËØªACK
[ ] Êé•Êî∂ËÄÖÊâìÂºÄËÅäÂ§©ÁïåÈù¢‚ÜíÂèëÈÄÅÂ∑≤ËØªACK‚ÜíÂèëÈÄÅËÄÖÊî∂Âà∞"Â∑≤ËØª"

# ÊµãËØïÁ¶ªÁ∫øÊ∂àÊÅØ
[ ] Êé•Êî∂ËÄÖÁ¶ªÁ∫ø‚ÜíÂèëÈÄÅÊ∂àÊÅØ‚ÜíÂ≠òÂÖ•ÈòüÂàó‚ÜíÊé•Êî∂ËÄÖ‰∏äÁ∫ø‚ÜíÊãâÂèñÊ∂àÊÅØ‚ÜíACK

# ÊµãËØïÊé®ÈÄÅÂ§±Ë¥•ÈáçËØï
[ ] Êé®ÈÄÅÂ§±Ë¥•‚ÜíËá™Âä®Â≠òÂÖ•Á¶ªÁ∫øÈòüÂàó‚ÜíÊé•Êî∂ËÄÖÊãâÂèñ
```

---

# üìã Á¨¨‰∫åÂë®: P1ÈáçË¶Å‰ºòÂåñ

## ‰ªªÂä°4: Protocol BuffersÂÆûÁé∞ (2Â§©) üü°

(ËØ¶ÁªÜÂÆûÊñΩÊ≠•È™§ËßÅÂÆåÊï¥ÊñáÊ°£...)

## ‰ªªÂä°5: Ê∂àÊÅØÂêåÊ≠•Êú∫Âà∂ (1Â§©) üü°

(ËØ¶ÁªÜÂÆûÊñΩÊ≠•È™§ËßÅÂÆåÊï¥ÊñáÊ°£...)

## ‰ªªÂä°6: Cloudflare TLSÈÖçÁΩÆÈ™åËØÅ (0.5Â§©) üü¢

### ÂÆûÊñΩÊ≠•È™§

#### Step 1: Cloudflare DashboardÊ£ÄÊü•

```
ÁôªÂΩï: https://dash.cloudflare.com
ÂüüÂêç: lanxin168.com

Ê£ÄÊü•È°π:
[ ] SSL/TLS ‚Üí Overview ‚Üí Full (strict) ‚úÖ
[ ] SSL/TLS ‚Üí Edge Certificates ‚Üí Always Use HTTPS ‚úÖ
[ ] SSL/TLS ‚Üí Edge Certificates ‚Üí Minimum TLS Version: 1.2+
[ ] SSL/TLS ‚Üí Edge Certificates ‚Üí TLS 1.3: Enabled
[ ] SSL/TLS ‚Üí Edge Certificates ‚Üí HSTS: Enabled
[ ] Security ‚Üí WAF: Enabled
[ ] Security ‚Üí DDoS: Automatic (ÈªòËÆ§ÂêØÁî®)
```

#### Step 2: ÂêéÁ´ØÈÖçÁΩÆÊõ¥Êñ∞

```yaml
# apps/backend/config/config.yaml
server:
  port: 8080
  mode: release  # Áîü‰∫ßÁéØÂ¢É
  domain: lanxin168.com
  
  # ‚úÖ Âº∫Âà∂HTTPS
  force_https: true
  
  # ‚úÖ HSTSËÆæÁΩÆ
  hsts_max_age: 31536000  # 1Âπ¥
  hsts_include_subdomains: true
  hsts_preload: true

security:
  # ‚úÖ TLSÈÖçÁΩÆ
  tls:
    min_version: "1.2"
    prefer_server_cipher_suites: true
    
  # ‚úÖ ‰ø°‰ªªCloudflare‰ª£ÁêÜ
  trusted_proxies:
    - "173.245.48.0/20"
    - "103.21.244.0/22"
    - "103.22.200.0/22"
    - "103.31.4.0/22"
    - "141.101.64.0/18"
    - "108.162.192.0/18"
    - "190.93.240.0/20"
    - "188.114.96.0/20"
    - "197.234.240.0/22"
    - "198.41.128.0/17"
    - "162.158.0.0/15"
    - "104.16.0.0/13"
    - "104.24.0.0/14"
    - "172.64.0.0/13"
    - "131.0.72.0/22"
```

#### Step 3: Gin‰∏≠Èó¥‰ª∂ÈÖçÁΩÆ

```go
// apps/backend/cmd/server/main.go

import (
    "github.com/gin-gonic/gin"
    "github.com/unrolled/secure"
)

func main() {
    r := gin.Default()
    
    // ‚úÖ ÂÆâÂÖ®‰∏≠Èó¥‰ª∂
    secureMiddleware := secure.New(secure.Options{
        SSLRedirect:          true,  // HTTP‚ÜíHTTPSÈáçÂÆöÂêë
        SSLHost:              "api.lanxin168.com",
        STSSeconds:           31536000,
        STSIncludeSubdomains: true,
        STSPreload:           true,
        FrameDeny:            true,
        ContentTypeNosniff:   true,
        BrowserXssFilter:     true,
        ContentSecurityPolicy: "default-src 'self'",
        IsDevelopment:        cfg.Server.Mode == "debug",
    })
    
    r.Use(func(c *gin.Context) {
        err := secureMiddleware.Process(c.Writer, c.Request)
        if err != nil {
            c.Abort()
            return
        }
        c.Next()
    })
    
    // ‚úÖ ‰ø°‰ªªCloudflare‰ª£ÁêÜ
    r.SetTrustedProxies(cfg.Security.TrustedProxies)
    
    // ... ÂÖ∂‰ªñË∑ØÁî± ...
}
```

#### Step 4: WebSocket WSSÈÖçÁΩÆ

```kotlin
// apps/android/app/src/main/java/com/lanxin/im/data/remote/WebSocketClient.kt

class WebSocketClient {
    companion object {
        // ‚úÖ ÂøÖÈ°ª‰ΩøÁî®wss://ÔºàÂÆâÂÖ®WebSocketÔºâ
        private const val WS_URL = "wss://api.lanxin168.com/ws"
        // ‚ùå ‰∏çË¶Å‰ΩøÁî®ws://ÔºàÈùûÂä†ÂØÜÔºâ
    }
    
    private fun createWebSocket(token: String): WebSocket {
        val client = OkHttpClient.Builder()
            .connectTimeout(10, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            // ‚úÖ OkHttpËá™Âä®Â§ÑÁêÜWSSÂä†ÂØÜ
            .build()
        
        val request = Request.Builder()
            .url("$WS_URL?token=$token")
            .build()
        
        return client.newWebSocket(request, this)
    }
}
```

#### Step 5: SSLÊµãËØï

```bash
# 1. ÊµãËØïHTTPSËøûÊé•
curl -v https://api.lanxin168.com/health

ÊúüÊúõËæìÂá∫:
* SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384
* Server certificate:
*  subject: CN=*.lanxin168.com
*  issuer: C=US; O=Cloudflare, Inc.; CN=Cloudflare Inc ECC CA-3
*  SSL certificate verify ok.

# 2. ÊµãËØïHTTP‚ÜíHTTPSÈáçÂÆöÂêë
curl -I http://api.lanxin168.com/health

ÊúüÊúõËæìÂá∫:
HTTP/1.1 301 Moved Permanently
Location: https://api.lanxin168.com/health

# 3. ÊµãËØïHSTSÂ§¥
curl -I https://api.lanxin168.com/health | grep -i strict

ÊúüÊúõËæìÂá∫:
strict-transport-security: max-age=31536000; includeSubDomains; preload

# 4. SSL LabsÂÆåÊï¥ÊµãËØï
ËÆøÈóÆ: https://www.ssllabs.com/ssltest/analyze.html?d=api.lanxin168.com

ÊúüÊúõËØÑÂàÜ:
Overall Rating: A+ ‚úÖ
Certificate: 100
Protocol Support: 100
Key Exchange: 100
Cipher Strength: 90

# 5. ÊµãËØïWebSocketÂä†ÂØÜ
‰ΩøÁî®Chrome DevTools:
const ws = new WebSocket('wss://api.lanxin168.com/ws?token=xxx');
ws.onopen = () => console.log('‚úÖ WSSËøûÊé•ÊàêÂäü');

ÊúüÊúõ: 
- ËøûÊé•ÊàêÂäü
- NetworkÈù¢ÊùøÊòæÁ§∫wss://ÂçèËÆÆÔºàÁªøËâ≤Â∞èÈîÅÂõæÊ†áÔºâ
```

#### Step 6: ÂÆâÂÖ®headerÈ™åËØÅ

```bash
# Ê£ÄÊü•ÊâÄÊúâÂÆâÂÖ®header
curl -I https://api.lanxin168.com/health

ÊúüÊúõÂåÖÂê´:
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
Content-Security-Policy: default-src 'self'
CF-Ray: xxx-xxx  # CloudflareÊ†áËØÜ
```

### È™åÊî∂Ê†áÂáÜ

```
[ ] Cloudflare SSLËÆæÁΩÆ‰∏∫Full (strict)
[ ] HTTPSÂº∫Âà∂ÈáçÂÆöÂêëÂ∑•‰ΩúÊ≠£Â∏∏
[ ] HSTSÂ§¥Ê≠£Á°ÆÈÖçÁΩÆ
[ ] TLS 1.3ÂêØÁî®
[ ] SSL LabsËØÑÂàÜA+
[ ] WebSocket‰ΩøÁî®wss://ÂçèËÆÆ
[ ] ÊâÄÊúâÂÆâÂÖ®headerÊ≠£Á°Æ
[ ] ‰ø°‰ªªCloudflare‰ª£ÁêÜIP
```

### ÂÆâÂÖ®Á≠âÁ∫ßËØÑ‰º∞

**‰º†ËæìÂ±ÇÂÆâÂÖ®**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê 5/5
- CloudflareÂÖ®ÁêÉCDN
- TLS 1.3ÊúÄÊñ∞Ê†áÂáÜ
- Ëá™Âä®DDoSÈò≤Êä§
- WAFÈò≤Êä§

**ËÆ§ËØÅÂÆâÂÖ®**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê 5/5  
- JWT Token
- bcryptÂØÜÁ†ÅÂìàÂ∏å
- TokenÈªëÂêçÂçï

**Â≠òÂÇ®ÂÆâÂÖ®**: ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ 3/5
- ÊòéÊñáÂ≠òÂÇ®Ôºà‰ºÅ‰∏öIMÊ†áÂáÜÔºâ
- ÈÄÇÂêàÈúÄË¶ÅÂÆ°ËÆ°ÁöÑ‰ºÅ‰∏öÂú∫ÊôØ

**ÁªºÂêàÂÆâÂÖ®Á≠âÁ∫ß**: ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ 4.3/5
**ÁªìËÆ∫**: Á¨¶Âêà‰ºÅ‰∏öÁ∫ßIMÂÆâÂÖ®Ê†áÂáÜÔºå‰∏éÂæÆ‰ø°‰ºÅ‰∏öÁâà/ÈíâÈíâÂêåÁ∫ßÂà´ ‚úÖ

---

# üìä ËøõÂ∫¶Ë∑üË∏™Ë°®

| ‰ªªÂä° | È¢ÑËÆ°Â∑•Êúü | ÂÆûÈôÖÂ∑•Êúü | Áä∂ÊÄÅ | Â§áÊ≥® |
|------|---------|---------|------|------|
| Áæ§ËÅäÂäüËÉΩ | 3-4Â§© | ___ | ‚è≥ Êú™ÂºÄÂßã | |
| WebSocketÁÆ°ÁêÜ | 2Â§© | ___ | ‚è≥ Êú™ÂºÄÂßã | |
| Ê∂àÊÅØÂèØÈù†ÊÄß | 2-3Â§© | ___ | ‚è≥ Êú™ÂºÄÂßã | |
| Protobuf | 2Â§© | ___ | ‚è≥ Êú™ÂºÄÂßã | |
| Ê∂àÊÅØÂêåÊ≠• | 1Â§© | ___ | ‚è≥ Êú™ÂºÄÂßã | |
| E2EE | 5-7Â§© | ___ | ‚è≥ Êú™ÂºÄÂßã | ÂèØÈÄâ |

---

# ‚úÖ È™åÊî∂Ê†áÂáÜ

## P0‰ªªÂä°È™åÊî∂

### Áæ§ËÅäÂäüËÉΩ
- [ ] ÂèØ‰ª•ÂàõÂª∫Áæ§ÁªÑ
- [ ] ÂèØ‰ª•ÂèëÈÄÅÁæ§Ê∂àÊÅØ
- [ ] ÂèØ‰ª•Ê∑ªÂä†/ÁßªÈô§ÊàêÂëò
- [ ] Âú®Á∫øÊàêÂëòÂÆûÊó∂Êî∂Âà∞Ê∂àÊÅØ
- [ ] Á¶ªÁ∫øÊàêÂëò‰∏äÁ∫øÂêéËÉΩÁúãÂà∞Ê∂àÊÅØ

### WebSocketÁÆ°ÁêÜ
- [ ] ÊîØÊåÅ10000+Âπ∂ÂèëËøûÊé•
- [ ] ÂÉµÂ∞∏ËøûÊé•Ëá™Âä®Ê∏ÖÁêÜ
- [ ] ËøûÊé•Êï∞ÈôêÂà∂ÁîüÊïà
- [ ] ÂéãÂäõÊµãËØïÈÄöËøá

### Ê∂àÊÅØÂèØÈù†ÊÄß
- [ ] Ê∂àÊÅØÈÄÅËææACKÂ∑•‰ΩúÊ≠£Â∏∏
- [ ] Ê∂àÊÅØÂ∑≤ËØªACKÂ∑•‰ΩúÊ≠£Â∏∏
- [ ] Á¶ªÁ∫øÊ∂àÊÅØÈòüÂàóÂ∑•‰ΩúÊ≠£Â∏∏
- [ ] Ê∂àÊÅØ‰∏ç‰∏¢Â§±

---

# üìû ÊîØÊåÅËµÑÊ∫ê

## ÂèÇËÄÉÊñáÊ°£
- `PROJECT_REVIEW_REPORT.md` - ËØ¶ÁªÜÂÆ°Êü•Êä•Âëä
- `IMÂÖ®Ê†àÂºÄÂèëÂÆåÊï¥Áü•ËØÜÂ∫ì.md` - ÂÆåÊï¥IMÁü•ËØÜ
- `apps/backend/API_DOCUMENTATION.md` - APIÊñáÊ°£

## ÊäÄÊúØÊîØÊåÅ
- ÈáéÁÅ´IMÊ∫êÁ†Å: `android-chat-master/`
- ÈáéÁÅ´IMÂÆòÊñπÊñáÊ°£: https://docs.wildfirechat.cn/

## ÊµãËØïÂ∑•ÂÖ∑
- WebSocketÊµãËØï: wscat, Browser Console
- APIÊµãËØï: Postman, curl
- ÂéãÂäõÊµãËØï: JMeter, Locust

---

**ÂàõÂª∫Êó∂Èó¥**: 2025-10-18  
**‰∏ãÊ¨°Êõ¥Êñ∞**: ÂÆåÊàêP0‰ªªÂä°Âêé

