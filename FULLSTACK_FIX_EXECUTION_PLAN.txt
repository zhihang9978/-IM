═══════════════════════════════════════════════════════════════
  全栈修复执行计划 - 完整代码版本
═══════════════════════════════════════════════════════════════

计划名称: 蓝信IM前后端集成完整修复
执行模式: PLAN → EXECUTE（严格执行，不允许偏离）
计划版本: v1.0
创建时间: 2025-10-17

⚠️⚠️⚠️ 本计划为强制执行文档 ⚠️⚠️⚠️
不允许任何偏离、简化、跳过
所有代码必须完整实现
所有测试必须通过

═══════════════════════════════════════════════════════════════
📊 计划总览
═══════════════════════════════════════════════════════════════

修复范围: 前端 + 后端全栈
修复缺陷: 13个（P0: 3个, P1: 4个, P2: 3个, P3: 3个）
新增API: 9个
新增功能: 5个
预计时间: 5天（40工作小时）
成功标准: 集成度100%，可用度95%+

当前状态 → 目标状态:
- API完整度: 64% → 100% (+36%)
- 数据完整度: 40% → 100% (+60%)
- 功能可用度: 50% → 95% (+45%)
- 集成完整度: 56% → 100% (+44%)

═══════════════════════════════════════════════════════════════
🔴 DAY 1: P0级缺陷修复（阻塞性问题）
═══════════════════════════════════════════════════════════════

工作时间: 8小时
目标: 消除3个阻塞性缺陷
成功标准: 核心功能全部可用，集成度达到75%

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
任务1.1: 实现历史消息加载API (2.5小时)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【步骤1.1.1】修改MessageDAO添加历史消息查询方法
────────────────────────────────────────────
文件路径: apps/backend/internal/dao/message_dao.go
操作类型: 添加方法
位置: 在文件末尾（最后一个方法之后）
完整代码:
```go
// GetHistoryMessages 获取历史消息（分页加载）
// 用途：支持Android客户端下拉加载更早的聊天记录
// 
// 参数说明：
//   conversationID - 会话ID
//   beforeMessageID - 加载此消息ID之前的消息（0表示加载最新的）
//   limit - 返回的消息数量限制（建议20条）
// 
// 返回说明：
//   返回消息列表，按时间正序排列（最早的在前）
//   包含Sender和Receiver的完整信息
// 
// 实现逻辑：
//   1. 查询conversation_id匹配的消息
//   2. 如果beforeMessageID>0，只查询id<beforeMessageID的消息
//   3. 按id降序排列，取limit条
//   4. Preload关联的用户信息
//   5. 反转数组使最早的消息在前
func (d *MessageDAO) GetHistoryMessages(conversationID, beforeMessageID uint, limit int) ([]model.Message, error) {
	var messages []model.Message
	
	// 构建查询条件
	query := d.db.Where("conversation_id = ?", conversationID)
	
	// 如果指定了beforeMessageID，只获取ID更小的消息（更早的消息）
	if beforeMessageID > 0 {
		query = query.Where("id < ?", beforeMessageID)
	}
	
	// 按ID倒序查询（最新的在前），限制数量，加载关联数据
	err := query.
		Order("id DESC").
		Limit(limit).
		Preload("Sender").   // 加载发送者信息
		Preload("Receiver"). // 加载接收者信息
		Find(&messages).Error
		
	if err != nil {
		return nil, err
	}
	
	// 反转数组，使最早的消息在前面（因为前端期望正序）
	for i, j := 0, len(messages)-1; i < j; i, j = i+1, j-1 {
		messages[i], messages[j] = messages[j], messages[i]
	}
	
	return messages, nil
}
```

验证检查:
- [ ] 代码已添加到message_dao.go末尾
- [ ] 注释完整清晰
- [ ] 参数类型正确
- [ ] 返回类型正确
- [ ] Preload包含Sender和Receiver

【步骤1.1.2】添加MessageService层方法
────────────────────────────────────────────
文件路径: apps/backend/internal/service/message_service.go
操作类型: 添加方法
位置: 在文件末尾
完整代码:
```go
// GetHistoryMessages 获取历史消息（业务层）
// 直接调用DAO层，未来可在此添加业务逻辑（如权限验证、敏感词过滤等）
func (s *MessageService) GetHistoryMessages(conversationID, beforeMessageID uint, limit int) ([]model.Message, error) {
	// 限制每次最多查询100条，防止数据量过大
	if limit > 100 {
		limit = 100
	}
	
	return s.messageDAO.GetHistoryMessages(conversationID, beforeMessageID, limit)
}
```

验证检查:
- [ ] 代码已添加到message_service.go
- [ ] 包含limit限制逻辑
- [ ] 调用messageDAO.GetHistoryMessages

【步骤1.1.3】创建API Handler
────────────────────────────────────────────
文件路径: apps/backend/internal/api/message.go
操作类型: 添加方法
位置: 在MarkAsRead方法之后添加
完整代码:
```go
// GetHistoryMessages 获取历史消息（API层）
// 路由: GET /api/v1/conversations/:id/messages/history
// 参数: 
//   - id (path): 会话ID
//   - before_message_id (query): 加载此消息之前的历史
//   - limit (query): 返回数量，默认20
// 返回: 
//   {code: 0, message: "success", data: {total: 20, messages: [...]}}
func (h *MessageHandler) GetHistoryMessages(c *gin.Context) {
	// 解析路径参数
	conversationID, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "Invalid conversation ID",
			"data":    nil,
		})
		return
	}
	
	// 解析查询参数
	beforeMessageID, _ := strconv.ParseUint(c.Query("before_message_id"), 10, 32)
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
	
	// 调用Service层
	messages, err := h.messageService.GetHistoryMessages(
		uint(conversationID),
		uint(beforeMessageID),
		limit,
	)
	
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": err.Error(),
			"data":    nil,
		})
		return
	}
	
	// 返回成功响应
	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"total":    len(messages),
			"messages": messages,
		},
	})
}
```

验证检查:
- [ ] 代码已添加到message.go
- [ ] 参数解析完整
- [ ] 错误处理完善
- [ ] 返回格式正确

【步骤1.1.4】注册API路由
────────────────────────────────────────────
文件路径: apps/backend/cmd/server/main.go
操作类型: 添加路由
位置: line 130之后（authorized.GET("/conversations/:id/messages"...)之后）
精确位置: 在GetMessages路由之后，MarkAsRead路由之前
完整代码:
```go
			// 获取历史消息（分页加载）
			authorized.GET("/conversations/:id/messages/history", messageHandler.GetHistoryMessages)
```

验证检查:
- [ ] 路由已添加在正确位置
- [ ] 路由路径完全匹配: /conversations/:id/messages/history
- [ ] handler方法名正确: messageHandler.GetHistoryMessages
- [ ] 在authorized组内（需要认证）

【步骤1.1.5】测试历史消息API
────────────────────────────────────────────
测试方法: 命令行 + Android客户端

后端测试命令:
```bash
# 1. 启动后端服务
cd apps/backend
go run cmd/server/main.go

# 2. 获取Token（另一个终端）
TOKEN=$(curl -X POST http://localhost:8080/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"identifier":"testuser","password":"password123"}' | jq -r '.data.token')

# 3. 测试历史消息API
curl -X GET "http://localhost:8080/api/v1/conversations/1/messages/history?before_message_id=100&limit=20" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" | jq

# 期望输出:
# {
#   "code": 0,
#   "message": "success",
#   "data": {
#     "total": 20,
#     "messages": [
#       {
#         "id": 80,
#         "conversation_id": 1,
#         "sender_id": 1,
#         "receiver_id": 2,
#         "content": "历史消息内容",
#         "type": "text",
#         "status": "read",
#         "created_at": "2025-10-16T10:00:00Z",
#         "sender": {...},
#         "receiver": {...}
#       },
#       // ... 更多消息，按时间正序
#     ]
#   }
# }
```

Android测试步骤:
1. 打开聊天页面（需要有消息记录）
2. 向下滚动到顶部
3. 下拉触发刷新
4. 观察加载指示器
5. 验证历史消息显示
6. 验证消息顺序正确
7. 验证滚动位置保持

测试检查清单:
- [ ] API返回200状态码
- [ ] 返回code=0
- [ ] messages数组不为空
- [ ] 消息按时间正序（早→晚）
- [ ] 包含sender和receiver信息
- [ ] Android下拉刷新成功
- [ ] 历史消息正确插入列表顶部
- [ ] 滚动位置正确保持

边界测试:
- [ ] beforeMessageID=0（加载最新）
- [ ] beforeMessageID=1（没有更早消息）
- [ ] limit=1（单条）
- [ ] limit=100（最大限制）
- [ ] conversationID不存在
- [ ] 无权限访问他人会话

如失败:
- 检查数据库是否有测试数据
- 检查路由是否正确注册
- 检查Token是否有效
- 查看后端日志排查错误

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
任务1.2: 完善会话列表数据 (3小时)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【步骤1.2.1】修改ConversationDAO添加关联查询
────────────────────────────────────────────
文件路径: apps/backend/internal/dao/conversation_dao.go
操作类型: 修改现有方法
方法名: GetUserConversations
精确修改:

查找代码:
```go
func (d *ConversationDAO) GetUserConversations(userID uint) ([]model.Conversation, error) {
	var conversations []model.Conversation
	err := d.db.Where("user1_id = ? OR user2_id = ?", userID, userID).
		Find(&conversations).Error
	return conversations, err
}
```

替换为:
```go
func (d *ConversationDAO) GetUserConversations(userID uint) ([]model.Conversation, error) {
	var conversations []model.Conversation
	
	// ✅ 添加完整的Preload加载关联数据
	err := d.db.
		Where("user1_id = ? OR user2_id = ?", userID, userID).
		Preload("User1").              // 加载User1完整信息
		Preload("User2").              // 加载User2完整信息
		Preload("Group").              // 加载Group信息（如果是群聊）
		Preload("LastMessage").        // 加载最后一条消息
		Preload("LastMessage.Sender"). // 加载消息发送者信息
		Order("updated_at DESC").      // 按更新时间倒序
		Find(&conversations).Error
		
	return conversations, err
}
```

验证检查:
- [ ] 代码已完整替换
- [ ] Preload包含5个关联
- [ ] Order语句存在
- [ ] 返回类型未改变

【步骤1.2.2】添加未读消息计数方法
────────────────────────────────────────────
文件路径: apps/backend/internal/dao/conversation_dao.go
操作类型: 添加新方法
位置: 在GetUserConversations方法之后
完整代码:
```go
// GetUnreadCount 获取会话的未读消息数量
// 
// 参数说明：
//   conversationID - 会话ID
//   userID - 当前用户ID（作为接收者）
// 
// 返回说明：
//   返回该会话中，接收者为userID且状态不为"read"的消息数量
// 
// 使用场景：
//   在会话列表中显示未读徽章
func (d *ConversationDAO) GetUnreadCount(conversationID, userID uint) int {
	var count int64
	
	// 统计条件：
	// 1. 属于该会话
	// 2. 接收者是当前用户
	// 3. 状态不是"read"（包括sent和delivered）
	d.db.Model(&model.Message{}).
		Where("conversation_id = ? AND receiver_id = ? AND status != ?", 
			conversationID, 
			userID, 
			model.MessageStatusRead).
		Count(&count)
		
	return int(count)
}
```

验证检查:
- [ ] 方法已添加
- [ ] SQL条件正确（3个WHERE）
- [ ] 返回int类型
- [ ] 注释完整

【步骤1.2.3】修改ConversationHandler返回完整数据
────────────────────────────────────────────
文件路径: apps/backend/internal/api/conversation.go
操作类型: 修改现有方法
方法名: GetConversations
精确修改:

查找代码（line 36-54）:
```go
	// 转换为响应格式
	items := make([]map[string]interface{}, len(conversations))
	for i, conv := range conversations {
		item := map[string]interface{}{
			"id":           conv.ID,
			"type":         conv.Type,
			"unread_count": 0, // TODO: 从未读消息表计算
			"updated_at":   conv.UpdatedAt.Unix(),
		}
		
		// 添加对方用户信息
		if conv.Type == "single" {
			if conv.User1ID != nil && *conv.User1ID != userID {
				item["user"] = conv.User1
			} else if conv.User2ID != nil {
				item["user"] = conv.User2
			}
		}
		
		items[i] = item
	}
```

替换为:
```go
	// 转换为响应格式（包含完整数据）
	items := make([]map[string]interface{}, len(conversations))
	for i, conv := range conversations {
		// ✅ 计算真实未读数（不再是硬编码0）
		unreadCount := h.conversationDAO.GetUnreadCount(conv.ID, userID)
		
		item := map[string]interface{}{
			"id":            conv.ID,
			"type":          conv.Type,
			"unread_count":  unreadCount,          // ✅ 真实计算的未读数
			"updated_at":    conv.UpdatedAt.Unix(),
			"last_message":  conv.LastMessage,     // ✅ 完整的最后一条消息
		}
		
		// ✅ 添加对方用户信息（单聊）
		if conv.Type == "single" {
			if conv.User1ID != nil && *conv.User1ID != userID {
				item["user"] = conv.User1
			} else if conv.User2ID != nil {
				item["user"] = conv.User2
			}
		} else if conv.Type == "group" && conv.Group != nil {
			// ✅ 群聊信息
			item["group"] = conv.Group
		}
		
		items[i] = item
	}
```

验证检查:
- [ ] TODO注释已移除
- [ ] unread_count调用GetUnreadCount
- [ ] last_message字段已添加
- [ ] group字段已添加

【步骤1.2.4】测试会话列表API
────────────────────────────────────────────
测试命令:
```bash
# 测试API
curl -X GET "http://localhost:8080/api/v1/conversations" \
  -H "Authorization: Bearer $TOKEN" | jq

# 期望输出:
# {
#   "code": 0,
#   "message": "success",
#   "data": {
#     "conversations": [
#       {
#         "id": 1,
#         "type": "single",
#         "user": {
#           "id": 2,
#           "username": "user2",
#           "avatar": "http://..."
#         },
#         "last_message": {
#           "id": 100,
#           "content": "最后一条消息内容",
#           "type": "text",
#           "created_at": "..."
#         },
#         "unread_count": 5,
#         "updated_at": 1697500000
#       }
#     ]
#   }
# }
```

Android测试:
1. 打开会话列表
2. 验证显示消息预览（不是"[消息]"）
3. 验证显示未读数（不是0）
4. 验证时间格式正确

测试检查清单:
- [ ] 返回last_message字段
- [ ] last_message不为null
- [ ] unread_count为真实数字
- [ ] user字段包含完整信息
- [ ] Android显示消息预览
- [ ] Android显示未读徽章

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
任务1.3: P0阶段集成测试 (2小时)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【端到端测试场景1】历史消息加载完整流程
────────────────────────────────────────────
1. 用户A和用户B建立会话
2. 发送100条测试消息
3. 用户A打开聊天页面
4. 验证显示最后50条消息
5. 下拉刷新加载历史
6. 验证加载20条更早的消息
7. 再次下拉刷新
8. 验证继续加载更早的消息
9. 直到显示"没有更多历史消息"

期望结果:
✅ 每次下拉加载20条
✅ 消息顺序正确
✅ 滚动位置保持
✅ 无重复消息

【端到端测试场景2】会话列表实时更新
────────────────────────────────────────────
1. 用户A打开会话列表
2. 用户B发送消息给用户A
3. 验证会话列表自动刷新
4. 验证显示最新消息内容
5. 验证未读数+1
6. 用户A打开会话
7. 验证未读数清零

期望结果:
✅ 实时收到消息
✅ 会话列表自动更新
✅ 消息预览正确显示
✅ 未读数准确

【性能测试】
────────────────────────────────────────────
测试工具: Apache Bench
```bash
# 测试历史消息API性能
ab -n 1000 -c 10 \
  -H "Authorization: Bearer $TOKEN" \
  "http://localhost:8080/api/v1/conversations/1/messages/history?limit=20"

# 期望:
# - 平均响应时间 < 100ms
# - 99%请求 < 200ms
# - 0%失败率
```

数据量测试:
- [ ] 100条消息
- [ ] 1000条消息
- [ ] 10000条消息
- [ ] 验证性能无明显下降

【P0阶段验收】
────────────────────────────────────────────
验收标准:
✅ 历史消息API可用
✅ 会话列表数据完整
✅ 所有测试通过
✅ 0编译错误
✅ 0运行时错误
✅ 集成度≥75%

验收人: 技术负责人
验收时间: Day 1结束前
验收结果文档: P0_VALIDATION_REPORT.txt

如验收失败:
- 记录失败原因
- 立即修复
- 重新验收
- 不得进入Day 2

═══════════════════════════════════════════════════════════════
🟡 DAY 2: P1级缺陷修复（高优先级问题）
═══════════════════════════════════════════════════════════════

工作时间: 8小时
目标: 实现联系人管理、密码修改、WebSocket处理
成功标准: 集成度达到90%

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
任务2.1: 实现联系人管理完整功能 (3小时)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

（详细步骤参见MASTER_FIX_PLAN_FULLSTACK.txt）
包含:
- AddContact API
- DeleteContact API
- UpdateRemark API
- 权限验证
- 重复检测
- 完整测试

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
任务2.2: 实现密码修改功能 (1.5小时)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

（详细代码参见MASTER_FIX_PLAN_FULLSTACK.txt）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
任务2.3: 完善WebSocket实时消息处理 (2小时)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

（详细代码参见MASTER_FIX_PLAN_FULLSTACK.txt）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
任务2.4: P1阶段集成测试 (1.5小时)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

全面测试所有P1功能

═══════════════════════════════════════════════════════════════
🟢 DAY 3-4: P2级功能补充（16小时）
═══════════════════════════════════════════════════════════════

详细实施步骤参见后续计划文档

═══════════════════════════════════════════════════════════════
🔵 DAY 5: P3级优化和最终测试（8小时）
═══════════════════════════════════════════════════════════════

详细实施步骤参见后续计划文档

═══════════════════════════════════════════════════════════════
📋 实施清单 - 编号顺序执行（不允许跳过）
═══════════════════════════════════════════════════════════════

Day 1 - P0缺陷修复（8小时）:
─────────────────────────────
1.  [ ] message_dao.go: 添加GetHistoryMessages方法
2.  [ ] message_service.go: 添加GetHistoryMessages方法
3.  [ ] message.go: 添加GetHistoryMessages handler
4.  [ ] main.go: 注册/conversations/:id/messages/history路由
5.  [ ] 测试历史消息API（curl命令）
6.  [ ] conversation_dao.go: 修改GetUserConversations添加Preload
7.  [ ] conversation_dao.go: 添加GetUnreadCount方法
8.  [ ] conversation.go: 修改GetConversations返回完整数据
9.  [ ] 测试会话列表API（curl命令）
10. [ ] Android测试历史消息加载
11. [ ] Android测试会话列表显示
12. [ ] 性能测试（1000条消息）
13. [ ] 边界测试（空数据、错误ID）
14. [ ] 创建P0验收报告
15. [ ] P0阶段验收（技术负责人签字）

Day 2 - P1缺陷修复（8小时）:
─────────────────────────────
16. [ ] contact_dao.go: 添加Delete方法
17. [ ] contact_dao.go: 添加UpdateRemark方法
18. [ ] contact_dao.go: 添加GetByID方法
19. [ ] contact_dao.go: 添加CheckExists方法
20. [ ] contact.go: 添加AddContact handler
21. [ ] contact.go: 添加DeleteContact handler
22. [ ] contact.go: 添加UpdateRemark handler
23. [ ] main.go: 注册POST /contacts路由
24. [ ] main.go: 注册DELETE /contacts/:id路由
25. [ ] main.go: 注册PUT /contacts/:id/remark路由
26. [ ] user_dao.go: 添加UpdatePassword方法
27. [ ] user_dao.go: 添加GetByID方法
28. [ ] user.go: 添加密码哈希函数
29. [ ] user.go: 添加ChangePassword handler
30. [ ] main.go: 注册PUT /users/me/password路由
31. [ ] go.mod: 添加bcrypt依赖
32. [ ] 创建WebSocketMessage.kt
33. [ ] 更新WebSocketClient.kt消息处理
34. [ ] ChatActivity.kt: 注册广播接收器
35. [ ] ChatListFragment.kt: 注册广播接收器
36. [ ] ApiService.kt: 添加updateContactRemark定义
37. [ ] RemarkActivity.kt: 更新为调用真实API
38. [ ] 测试添加联系人API
39. [ ] 测试删除联系人API
40. [ ] 测试设置备注API
41. [ ] 测试修改密码API
42. [ ] 测试WebSocket实时消息
43. [ ] 测试会话列表自动刷新
44. [ ] Android端到端测试
45. [ ] 创建P1验收报告
46. [ ] P1阶段验收

Day 3-4 - P2功能补充（16小时）:
─────────────────────────────
47. [ ] 创建008_favorites迁移文件
48. [ ] 创建favorite.go模型
49. [ ] 创建favorite_dao.go
50. [ ] 创建favorite.go handler
51. [ ] 注册收藏相关路由
52. [ ] 更新前端collectMessage调用
53. [ ] 创建009_reports迁移文件
54. [ ] 创建report.go模型
55. [ ] 创建report_dao.go
56. [ ] 创建report.go handler
57. [ ] 注册举报相关路由
58. [ ] 更新前端reportMessage调用
59. [ ] 实现消息搜索DAO方法
60. [ ] 实现消息搜索Service方法
61. [ ] 实现消息搜索Handler
62. [ ] 注册搜索路由
63. [ ] 修改所有DAO实现真实分页
64. [ ] 前端添加图片压缩实现
65. [ ] 前端添加视频压缩实现
66. [ ] 测试所有P2功能
67. [ ] P2阶段验收

Day 5 - P3优化（8小时）:
─────────────────────────────
68. [ ] 添加Redis缓存层
69. [ ] 添加文件类型验证
70. [ ] 添加文件大小限制
71. [ ] 性能优化（SQL索引）
72. [ ] 代码审查
73. [ ] 安全审计
74. [ ] 压力测试
75. [ ] 最终验收

总计: 75个检查点

═══════════════════════════════════════════════════════════════
⚠️ 严格执行规则
═══════════════════════════════════════════════════════════════

规则1: 顺序执行
- 必须按照编号1→2→3...→75顺序执行
- 不得跳过任何步骤
- 不得并行执行（除非明确标注可并行）

规则2: 验证确认
- 每个步骤完成后必须打勾✅
- 测试失败必须立即修复
- 所有检查点必须通过才能进入下一步

规则3: 代码质量
- 所有代码必须有注释
- 所有方法必须有文档说明
- 所有变量必须有意义的命名
- 遵循Go和Kotlin编码规范

规则4: 测试覆盖
- 每个API必须有curl测试
- 每个功能必须有Android测试
- 每个边界情况必须测试
- 所有测试必须通过

规则5: 文档同步
- 每天结束创建进度报告
- 记录所有遇到的问题
- 记录所有解决方案
- 更新API文档

规则6: Git提交规范
- 每完成一个任务提交一次
- 提交信息必须清晰
- 格式: "Fix P0-X: Description"
- 不得批量提交

规则7: 验收流程
- 每个阶段必须验收
- 验收不通过不得继续
- 验收报告必须存档
- 技术负责人必须签字

违反规则后果:
- 计划重新开始
- 已完成工作作废
- 重新评估时间

═══════════════════════════════════════════════════════════════
✅ 成功标准
═══════════════════════════════════════════════════════════════

Day 1成功标准:
✅ 历史消息可加载
✅ 会话列表数据完整
✅ 集成度≥75%
✅ P0验收通过

Day 2成功标准:
✅ 联系人可管理
✅ 密码可修改
✅ WebSocket实时通信
✅ 集成度≥90%
✅ P1验收通过

Day 3-4成功标准:
✅ 所有辅助功能实现
✅ 分页全部可用
✅ 压缩功能正常
✅ 集成度≥95%
✅ P2验收通过

Day 5成功标准:
✅ 性能优化完成
✅ 安全审计通过
✅ 压力测试通过
✅ 集成度=100%
✅ 最终验收通过

项目成功标准:
✅ 所有75个步骤完成
✅ 所有13个缺陷修复
✅ 所有测试通过
✅ 集成度100%
✅ 可用度95%+
✅ 可直接上线

═══════════════════════════════════════════════════════════════

下一步: 等待"ENTER EXECUTE MODE"指令开始执行
执行人员必须先阅读并确认理解本计划的所有内容

═══════════════════════════════════════════════════════════════

